(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
/// <reference path="../../../default/typescript/typescriptAPI/TypeScriptAPIPlugin.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });

SupCore.system.registerPlugin("typescriptAPI", "socketio", {
    code: "",
    defs: "// Type definitions for socket.io-client 1.4.5\r\n// Project: http://socket.io/\r\n// Definitions by: PROGRE <https://github.com/progre>, Damian Connolly <https://github.com/divillysausages>, Florent Poujol <https://github.com/florentpoujol>\r\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\r\n\r\ndeclare var io: SocketIOClientStatic;\r\n\r\ndeclare module 'socket.io-client' {\r\n\texport = io;\r\n}\r\n\r\ninterface SocketIOClientStatic {\r\n\r\n\t/**\r\n\t * Looks up an existing 'Manager' for multiplexing. If the user summons:\r\n\t * \t'io( 'http://localhost/a' );'\r\n\t * \t'io( 'http://localhost/b' );'\r\n\t *\r\n\t * We reuse the existing instance based on the same scheme/port/host, and\r\n\t * we initialize sockets for each namespace. If autoConnect isn't set to\r\n\t * false in the options, then we'll automatically connect\r\n\t * @param uri The uri that we'll connect to, including the namespace, where '/' is the default one (e.g. http://localhost:4000/somenamespace)\r\n\t * @opts Any connect options that we want to pass along\r\n\t * @return A Socket object\r\n\t */\r\n\t( uri: string, opts?: SocketIOClient.ConnectOpts ): SocketIOClient.Socket;\r\n\r\n\t/**\r\n\t * Auto-connects to the window location and defalt namespace.\r\n\t * E.g. window.protocol + '//' + window.host + ':80/'\r\n\t * @opts Any connect options that we want to pass along\r\n\t * @return A Socket object\r\n\t */\r\n\t( opts?: SocketIOClient.ConnectOpts ): SocketIOClient.Socket;\r\n\r\n\t/**\r\n\t * @see the default constructor (io(uri, opts))\r\n\t */\r\n\tconnect( uri: string, opts?: SocketIOClient.ConnectOpts ): SocketIOClient.Socket;\r\n\r\n\t/**\r\n\t * @see the default constructor (io(opts))\r\n\t */\r\n\tconnect( opts?: SocketIOClient.ConnectOpts ): SocketIOClient.Socket;\r\n\r\n\t/**\r\n\t * The socket.io protocol revision number this client works with\r\n\t * @default 4\r\n\t */\r\n\tprotocol: number;\r\n\r\n\t/**\r\n\t * Socket constructor - exposed for the standalone build\r\n\t */\r\n\tSocket: SocketIOClient.Socket;\r\n\r\n\t/**\r\n\t * Manager constructor - exposed for the standalone build\r\n\t */\r\n\tManager: SocketIOClient.ManagerStatic;\r\n\r\n    /**\r\n     * Managers cache\r\n     */\r\n    managers: { [key: string]: SocketIOClient.Manager }\r\n}\r\n\r\ndeclare namespace SocketIOClient {\r\n\r\n\t/**\r\n\t * The base emiter class, used by Socket and Manager\r\n\t */\r\n\tinterface Emitter {\r\n\t\t/**\r\n\t\t * Adds a listener for a particular event. Calling multiple times will add\r\n\t\t * multiple listeners\r\n\t\t * @param event The event that we're listening for\r\n\t\t * @param fn The function to call when we get the event. Parameters depend on the\r\n\t\t * event in question\r\n\t\t * @return This Emitter\r\n\t\t */\r\n\t\ton( event: string, fn: Function ):Emitter;\r\n\r\n\t\t/**\r\n\t\t * @see on( event, fn )\r\n\t\t */\r\n\t\taddEventListener( event: string, fn: Function ):Emitter;\r\n\r\n\t\t/**\r\n\t\t * Adds a listener for a particular event that will be invoked\r\n\t\t * a single time before being automatically removed\r\n\t\t * @param event The event that we're listening for\r\n\t\t * @param fn The function to call when we get the event. Parameters depend on\r\n\t\t * the event in question\r\n\t\t * @return This Emitter\r\n\t\t */\r\n\t\tonce( event: string, fn: Function ):Emitter;\r\n\r\n\t\t/**\r\n\t\t * Removes a listener for a particular type of event. This will either\r\n\t\t * remove a specific listener, or all listeners for this type of event\r\n\t\t * @param event The event that we want to remove the listener of\r\n\t\t * @param fn The function to remove, or null if we want to remove all functions\r\n\t\t * @return This Emitter\r\n\t\t */\r\n\t\toff( event: string, fn?: Function ):Emitter;\r\n\r\n\t\t/**\r\n\t\t * @see off( event, fn )\r\n\t\t */\r\n\t\tremoveListener( event: string, fn?: Function ):Emitter;\r\n\r\n\t\t/**\r\n\t\t * @see off( event, fn )\r\n\t\t */\r\n\t\tremoveEventListener( event: string, fn?: Function ):Emitter;\r\n\r\n\t\t/**\r\n\t\t * Removes all event listeners on this object\r\n\t\t * @return This Emitter\r\n\t\t */\r\n\t\tremoveAllListeners():Emitter;\r\n\r\n\t\t/**\r\n\t\t * Emits 'event' with the given args\r\n\t\t * @param event The event that we want to emit\r\n\t\t * @param args Optional arguments to emit with the event\r\n\t\t * @return Emitter\r\n\t\t */\r\n\t\temit( event: string, ...args: any[] ):Emitter;\r\n\r\n\t\t/**\r\n\t\t * Returns all the callbacks for a particular event\r\n\t\t * @param event The event that we're looking for the callbacks of\r\n\t\t * @return An array of callback Functions, or an empty array if we don't have any\r\n\t\t */\r\n\t\tlisteners( event: string ):Function[];\r\n\r\n\t\t/**\r\n\t\t * Returns if we have listeners for a particular event\r\n\t\t * @param event The event that we want to check if we've listeners for\r\n\t\t * @return True if we have listeners for this event, false otherwise\r\n\t\t */\r\n\t\thasListeners( event: string ):boolean;\r\n\t}\r\n\r\n\t/**\r\n\t * The Socket static interface\r\n\t */\r\n\tinterface SocketStatic {\r\n\r\n\t\t/**\r\n\t\t * Creates a new Socket, used for communicating with a specific namespace\r\n\t\t * @param io The Manager that's controlling this socket\r\n\t\t * @param nsp The namespace that this socket is for (@default '/')\r\n\t\t * @return A new Socket\r\n\t\t */\r\n\t\t( io: SocketIOClient.Manager, nsp: string ): Socket;\r\n\r\n\t\t/**\r\n\t\t * Creates a new Socket, used for communicating with a specific namespace\r\n\t\t * @param io The Manager that's controlling this socket\r\n\t\t * @param nsp The namespace that this socket is for (@default '/')\r\n\t\t * @return A new Socket\r\n\t\t */\r\n\t\tnew ( url: string, opts: any ): SocketIOClient.Manager;\r\n\t}\r\n\r\n\t/**\r\n\t * The Socket that we use to connect to a Namespace on the server\r\n\t */\r\n\tinterface Socket extends Emitter {\r\n\r\n\t\t/**\r\n\t\t * The Manager that's controller this socket\r\n\t\t */\r\n\t\tio: SocketIOClient.Manager;\r\n\r\n\t\t/**\r\n\t\t * The namespace that this socket is for\r\n\t\t * @default '/'\r\n\t\t */\r\n\t\tnsp: string;\r\n\r\n\t\t/**\r\n\t\t * The ID of the socket; matches the server ID and is set when we're connected, and cleared\r\n\t\t * when we're disconnected\r\n\t\t */\r\n\t\tid: string;\r\n\r\n\t\t/**\r\n\t\t * Are we currently connected?\r\n\t\t * @default false\r\n\t\t */\r\n\t\tconnected: boolean;\r\n\r\n\t\t/**\r\n\t\t * Are we currently disconnected?\r\n\t\t * @default true\r\n\t\t */\r\n\t\tdisconnected: boolean;\r\n\r\n\t\t/**\r\n\t\t * Opens our socket so that it connects. If the 'autoConnect' option for io is\r\n\t\t * true (default), then this is called automatically when the Socket is created\r\n\t\t */\r\n\t\topen(): Socket;\r\n\r\n\t\t/**\r\n\t\t * @see open();\r\n\t\t */\r\n\t\tconnect(): Socket;\r\n\r\n\t\t/**\r\n\t\t * Sends a 'message' event\r\n\t\t * @param args Any optional arguments that we want to send\r\n\t\t * @see emit\r\n\t\t * @return This Socket\r\n\t\t */\r\n\t\tsend( ...args: any[] ):Socket;\r\n\r\n\t\t/**\r\n\t\t * An override of the base emit. If the event is one of:\r\n\t\t * \tconnect\r\n\t\t * \tconnect_error\r\n\t\t * \tconnect_timeout\r\n\t\t * \tconnecting\r\n\t\t * \tdisconnect\r\n\t\t * \terror\r\n\t\t * \treconnect\r\n\t\t * \treconnect_attempt\r\n\t\t * \treconnect_failed\r\n\t\t * \treconnect_error\r\n\t\t * \treconnecting\r\n\t\t * \tping\r\n\t\t * \tpong\r\n\t\t * then the event is emitted normally. Otherwise, if we're connected, the\r\n\t\t * event is sent. Otherwise, it's buffered.\r\n\t\t *\r\n\t\t * If the last argument is a function, then it will be called\r\n\t\t * as an 'ack' when the response is received. The parameter(s) of the\r\n\t\t * ack will be whatever data is returned from the event\r\n\t\t * @param event The event that we're emitting\r\n\t\t * @param args Optional arguments to send with the event\r\n\t\t * @return This Socket\r\n\t\t */\r\n\t\temit( event: string, ...args: any[] ):Socket;\r\n\r\n\t\t/**\r\n\t\t * Disconnects the socket manually\r\n\t\t * @return This Socket\r\n\t\t */\r\n\t\tclose():Socket;\r\n\r\n\t\t/**\r\n\t\t * @see close()\r\n\t\t */\r\n\t\tdisconnect():Socket;\r\n\r\n\t\t/**\r\n\t\t* Sets the compress flag.\r\n\t\t* @param compress If `true`, compresses the sending data\r\n\t\t* @return this Socket\r\n\t\t*/\r\n\t\tcompress(compress: boolean):Socket;\r\n\t}\r\n\r\n\t/**\r\n\t * The Manager static interface\r\n\t */\r\n\tinterface ManagerStatic {\r\n\t\t/**\r\n\t\t * Creates a new Manager\r\n\t\t * @param uri The URI that we're connecting to (e.g. http://localhost:4000)\r\n\t\t * @param opts Any connection options that we want to use (and pass to engine.io)\r\n\t\t * @return A Manager\r\n\t\t */\r\n\t\t( uri: string, opts?: SocketIOClient.ConnectOpts ): SocketIOClient.Manager;\r\n\r\n\t\t/**\r\n\t\t * Creates a new Manager with the default URI (window host)\r\n\t\t * @param opts Any connection options that we want to use (and pass to engine.io)\r\n\t\t */\r\n\t\t( opts: SocketIOClient.ConnectOpts ):SocketIOClient.Manager;\r\n\r\n\t\t/**\r\n\t\t * @see default constructor\r\n\t\t */\r\n\t\tnew ( uri: string, opts?: SocketIOClient.ConnectOpts ): SocketIOClient.Manager;\r\n\r\n\t\t/**\r\n\t\t * @see default constructor\r\n\t\t */\r\n\t\tnew ( opts: SocketIOClient.ConnectOpts ):SocketIOClient.Manager;\r\n\t}\r\n\r\n\t/**\r\n\t * The Manager class handles all the Namespaces and Sockets that we're using\r\n\t */\r\n\tinterface Manager extends Emitter {\r\n\r\n\t\t/**\r\n\t\t * All the namespaces currently controlled by this Manager, and the Sockets\r\n\t\t * that we're using to communicate with them\r\n\t\t */\r\n\t\tnsps: { [namespace:string]: Socket };\r\n\r\n\t\t/**\r\n\t\t * The connect options that we used when creating this Manager\r\n\t\t */\r\n\t\topts: SocketIOClient.ConnectOpts;\r\n\r\n\t\t/**\r\n\t\t * The state of the Manager. Either 'closed', 'opening', or 'open'\r\n\t\t */\r\n\t\treadyState: string;\r\n\r\n\t\t/**\r\n\t\t * The URI that this manager is for (host + port), e.g. 'http://localhost:4000'\r\n\t\t */\r\n\t\turi: string;\r\n\r\n\t\t/**\r\n\t\t * The currently connected sockets\r\n\t\t */\r\n\t\tconnecting: Socket[];\r\n\r\n\t\t/**\r\n\t\t * If we should auto connect (also used when creating Sockets). Set via the\r\n\t\t * opts object\r\n\t\t */\r\n\t\tautoConnect: boolean;\r\n\r\n\t\t/**\r\n\t\t * Gets if we should reconnect automatically\r\n\t\t * @default true\r\n\t\t */\r\n\t\treconnection(): boolean;\r\n\r\n\t\t/**\r\n\t\t * Sets if we should reconnect automatically\r\n\t\t * @param v True if we should reconnect automatically, false otherwise\r\n\t\t * @default true\r\n\t\t * @return This Manager\r\n\t\t */\r\n\t\treconnection( v: boolean ): Manager;\r\n\r\n\t\t/**\r\n\t\t * Gets the number of reconnection attempts we should try before giving up\r\n\t\t * @default Infinity\r\n\t\t */\r\n\t\treconnectionAttempts(): number;\r\n\r\n\t\t/**\r\n\t\t * Sets the number of reconnection attempts we should try before giving up\r\n\t\t * @param v The number of attempts we should do before giving up\r\n\t\t * @default Infinity\r\n\t\t * @return This Manager\r\n\t\t */\r\n\t\treconnectionAttempts( v: number ): Manager;\r\n\r\n\t\t/**\r\n\t\t * Gets the delay in milliseconds between each reconnection attempt\r\n\t\t * @default 1000\r\n\t\t */\r\n\t\treconnectionDelay(): number;\r\n\r\n\t\t/**\r\n\t\t * Sets the delay in milliseconds between each reconnection attempt\r\n\t\t * @param v The delay in milliseconds\r\n\t\t * @default 1000\r\n\t\t * @return This Manager\r\n\t\t */\r\n\t\treconnectionDelay( v: number ): Manager;\r\n\r\n\t\t/**\r\n\t\t * Gets the max reconnection delay in milliseconds between each reconnection\r\n\t\t * attempt\r\n\t\t * @default 5000\r\n\t\t */\r\n\t\treconnectionDelayMax(): number;\r\n\r\n\t\t/**\r\n\t\t * Sets the max reconnection delay in milliseconds between each reconnection\r\n\t\t * attempt\r\n\t\t * @param v The max reconnection dleay in milliseconds\r\n\t\t * @return This Manager\r\n\t\t */\r\n\t\treconnectionDelayMax( v: number ): Manager;\r\n\r\n\t\t/**\r\n\t\t * Gets the randomisation factor used in the exponential backoff jitter\r\n\t\t * when reconnecting\r\n\t\t * @default 0.5\r\n\t\t */\r\n\t\trandomizationFactor(): number;\r\n\r\n\t\t/**\r\n\t\t * Sets the randomisation factor used in the exponential backoff jitter\r\n\t\t * when reconnecting\r\n\t\t * @param The reconnection randomisation factor\r\n\t\t * @default 0.5\r\n\t\t * @return This Manager\r\n\t\t */\r\n\t\trandomizationFactor( v: number ): Manager;\r\n\r\n\t\t/**\r\n\t\t * Gets the timeout in milliseconds for our connection attempts\r\n\t\t * @default 20000\r\n\t\t */\r\n\t\ttimeout(): number;\r\n\r\n\t\t/**\r\n\t\t * Sets the timeout in milliseconds for our connection attempts\r\n\t\t * @param The connection timeout milliseconds\r\n\t\t * @return This Manager\r\n\t\t */\r\n\t\ttimeout(v: number): Manager;\r\n\r\n\t\t/**\r\n\t\t * Sets the current transport socket and opens our connection\r\n\t\t * @param fn An optional callback to call when our socket has either opened, or\r\n\t\t * failed. It can take one optional parameter of type Error\r\n\t\t * @return This Manager\r\n\t\t */\r\n\t\topen( fn?: (err?: any) => void ): Manager;\r\n\r\n\t\t/**\r\n\t\t * @see open( fn );\r\n\t\t */\r\n\t\tconnect( fn?: (err?: any) => void ): Manager;\r\n\r\n\t\t/**\r\n\t\t * Creates a new Socket for the given namespace\r\n\t\t * @param nsp The namespace that this Socket is for\r\n\t\t * @return A new Socket, or if one has already been created for this namespace,\r\n\t\t * an existing one\r\n\t\t */\r\n\t\tsocket( nsp: string ): Socket;\r\n\t}\r\n\r\n\t/**\r\n\t * Options we can pass to the socket when connecting\r\n\t */\r\n\tinterface ConnectOpts {\r\n\r\n\t\t/**\r\n\t\t * Should we force a new Manager for this connection?\r\n\t\t * @default false\r\n\t\t */\r\n\t\tforceNew?: boolean;\r\n\r\n\t\t/**\r\n\t\t * Should we multiplex our connection (reuse existing Manager) ?\r\n\t\t * @default true\r\n\t\t */\r\n\t\tmultiplex?: boolean;\r\n\r\n\t\t/**\r\n\t\t * The path to get our client file from, in the case of the server\r\n\t\t * serving it\r\n\t\t * @default '/socket.io'\r\n\t\t */\r\n\t\tpath?: string;\r\n\r\n\t\t/**\r\n\t\t * Should we allow reconnections?\r\n\t\t * @default true\r\n\t\t */\r\n\t\treconnection?: boolean;\r\n\r\n\t\t/**\r\n\t\t * How many reconnection attempts should we try?\r\n\t\t * @default Infinity\r\n\t\t */\r\n\t\treconnectionAttempts?: number;\r\n\r\n\t\t/**\r\n\t\t * The time delay in milliseconds between reconnection attempts\r\n\t\t * @default 1000\r\n\t\t */\r\n\t\treconnectionDelay?: number;\r\n\r\n\t\t/**\r\n\t\t * The max time delay in milliseconds between reconnection attempts\r\n\t\t * @default 5000\r\n\t\t */\r\n\t\treconnectionDelayMax?: number;\r\n\r\n\t\t/**\r\n\t\t * Used in the exponential backoff jitter when reconnecting\r\n\t\t * @default 0.5\r\n\t\t */\r\n\t\trandomizationFactor?: number;\r\n\r\n\t\t/**\r\n\t\t * The timeout in milliseconds for our connection attempt\r\n\t\t * @default 20000\r\n\t\t */\r\n\t\ttimeout?: number;\r\n\r\n\t\t/**\r\n\t\t * Should we automically connect?\r\n\t\t * @default true\r\n\t\t */\r\n\t\tautoConnect?: boolean;\r\n\r\n\t\t/**\r\n\t\t * The host that we're connecting to. Set from the URI passed when connecting\r\n\t\t */\r\n\t\thost?: string;\r\n\r\n\t\t/**\r\n\t\t * The hostname for our connection. Set from the URI passed when connecting\r\n\t\t */\r\n\t\thostname?: string;\r\n\r\n\t\t/**\r\n\t\t * If this is a secure connection. Set from the URI passed when connecting\r\n\t\t */\r\n\t\tsecure?: boolean;\r\n\r\n\t\t/**\r\n\t\t * The port for our connection. Set from the URI passed when connecting\r\n\t\t */\r\n\t\tport?: string;\r\n\r\n\t\t/**\r\n\t\t * Any query parameters in our uri. Set from the URI passed when connecting\r\n\t\t */\r\n\t\tquery?: Object;\r\n\r\n\t\t/**\r\n\t\t * `http.Agent` to use, defaults to `false` (NodeJS only)\r\n\t\t */\r\n\t\tagent?: string|boolean;\r\n\r\n\t\t/**\r\n\t\t * Whether the client should try to upgrade the transport from\r\n\t\t * long-polling to something better.\r\n\t\t * @default true\r\n\t\t */\r\n\t\tupgrade?: boolean;\r\n\r\n\t\t/**\r\n\t\t * Forces JSONP for polling transport.\r\n\t\t */\r\n\t\tforceJSONP?: boolean;\r\n\r\n\t\t/**\r\n\t\t * Determines whether to use JSONP when necessary for polling. If\r\n\t\t * disabled (by settings to false) an error will be emitted (saying\r\n\t\t * \"No transports available\") if no other transports are available.\r\n\t\t * If another transport is available for opening a connection (e.g.\r\n\t\t * WebSocket) that transport will be used instead.\r\n\t\t * @default true\r\n\t\t */\r\n\t\tjsonp?: boolean;\r\n\r\n\t\t/**\r\n\t\t * Forces base 64 encoding for polling transport even when XHR2\r\n\t\t * responseType is available and WebSocket even if the used standard\r\n\t\t * supports binary.\r\n\t\t */\r\n\t\tforceBase64?: boolean;\r\n\r\n\t\t/**\r\n\t\t * Enables XDomainRequest for IE8 to avoid loading bar flashing with\r\n\t\t * click sound. default to `false` because XDomainRequest has a flaw\r\n\t\t * of not sending cookie.\r\n\t\t * @default false\r\n\t\t */\r\n\t\tenablesXDR?: boolean;\r\n\r\n\t\t/**\r\n\t\t * The param name to use as our timestamp key\r\n\t\t * @default 't'\r\n\t\t */\r\n\t\ttimestampParam?: string;\r\n\r\n\t\t/**\r\n\t\t * Whether to add the timestamp with each transport request. Note: this\r\n\t\t * is ignored if the browser is IE or Android, in which case requests\r\n\t\t * are always stamped\r\n\t\t * @default false\r\n\t\t */\r\n\t\ttimestampRequests?: boolean;\r\n\r\n\t\t/**\r\n\t\t * A list of transports to try (in order). Engine.io always attempts to\r\n\t\t * connect directly with the first one, provided the feature detection test\r\n\t\t * for it passes.\r\n\t\t * @default ['polling','websocket']\r\n\t\t */\r\n\t\ttransports?: string[];\r\n\r\n\t\t/**\r\n\t\t * The port the policy server listens on\r\n\t\t * @default 843\r\n\t\t */\r\n\t\tpolicyPost?: number;\r\n\r\n\t\t/**\r\n\t\t * If true and if the previous websocket connection to the server succeeded,\r\n\t\t * the connection attempt will bypass the normal upgrade process and will\r\n\t\t * initially try websocket. A connection attempt following a transport error\r\n\t\t * will use the normal upgrade process. It is recommended you turn this on\r\n\t\t * only when using SSL/TLS connections, or if you know that your network does\r\n\t\t * not block websockets.\r\n\t\t * @default false\r\n\t\t */\r\n\t\trememberUpgrade?: boolean;\r\n\r\n\t\t/**\r\n\t\t * Are we only interested in transports that support binary?\r\n\t\t */\r\n\t\tonlyBinaryUpgrades?: boolean;\r\n\r\n\t\t/**\r\n\t\t * Transport options for Node.js client (headers etc)\r\n\t\t */\r\n\t\ttransportOptions?: Object;\r\n\r\n\t\t/**\r\n\t\t * (SSL) Certificate, Private key and CA certificates to use for SSL.\r\n\t\t * Can be used in Node.js client environment to manually specify\r\n\t\t * certificate information.\r\n\t\t */\r\n\t\tpfx?: string;\r\n\r\n\t\t/**\r\n\t\t * (SSL) Private key to use for SSL. Can be used in Node.js client\r\n\t\t * environment to manually specify certificate information.\r\n\t\t */\r\n\t\tkey?: string;\r\n\r\n\t\t/**\r\n\t\t * (SSL) A string or passphrase for the private key or pfx. Can be\r\n\t\t * used in Node.js client environment to manually specify certificate\r\n\t\t * information.\r\n\t\t */\r\n\t\tpassphrase?: string\r\n\r\n\t\t/**\r\n\t\t * (SSL) Public x509 certificate to use. Can be used in Node.js client\r\n\t\t * environment to manually specify certificate information.\r\n\t\t */\r\n\t\tcert?: string;\r\n\r\n\t\t/**\r\n\t\t * (SSL) An authority certificate or array of authority certificates to\r\n\t\t * check the remote host against.. Can be used in Node.js client\r\n\t\t * environment to manually specify certificate information.\r\n\t\t */\r\n\t\tca?: string|string[];\r\n\r\n\t\t/**\r\n\t\t * (SSL) A string describing the ciphers to use or exclude. Consult the\r\n\t\t * [cipher format list]\r\n\t\t * (http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT) for\r\n\t\t * details on the format.. Can be used in Node.js client environment to\r\n\t\t * manually specify certificate information.\r\n\t\t */\r\n\t\tciphers?: string;\r\n\r\n\t\t/**\r\n\t\t * (SSL) If true, the server certificate is verified against the list of\r\n\t\t * supplied CAs. An 'error' event is emitted if verification fails.\r\n\t\t * Verification happens at the connection level, before the HTTP request\r\n\t\t * is sent. Can be used in Node.js client environment to manually specify\r\n\t\t * certificate information.\r\n\t\t */\r\n\t\trejectUnauthorized?: boolean;\r\n\r\n\t}\r\n}\r\n"
});

},{}]},{},[1]);
