(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
/// <reference path="../../typescript/typescriptAPI/TypeScriptAPIPlugin.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });

SupCore.system.registerPlugin("typescriptAPI", "Sup.Scene", {
    code: "namespace Sup {\r\n  const tmpVector3 = new SupEngine.THREE.Vector3();\r\n  const tmpQuaternion = new SupEngine.THREE.Quaternion();\r\n\r\n  export class Scene extends Asset {}\r\n\r\n  export function loadScene(pathOrAsset) {\r\n    player.gameInstance.destroyAllActors();\r\n    appendSceneInternal(pathOrAsset);\r\n  }\r\n  \r\n  export function appendScene(pathOrAsset: string|Scene, parent?: Actor) {\r\n    return appendSceneInternal(pathOrAsset, parent);\r\n  }\r\n\r\n  function appendSceneInternal(pathOrAsset: string|Scene, rootParentActor?: Actor, prefabNode?: any): any {\r\n    const sceneAsset = (typeof pathOrAsset === \"string\") ? get(pathOrAsset, Scene) : pathOrAsset as Scene;\r\n\r\n    const actors: Actor[] = [];\r\n    let allComponents = [];\r\n\r\n    const walk = (node, parentActor) => {\r\n      let actor: Actor;\r\n      if (node.prefab != null) {\r\n        const prefabAsset = player.getOuterAsset(node.prefab.sceneAssetId);\r\n        if (prefabAsset != null) {\r\n          const result = appendSceneInternal(prefabAsset, parentActor, node);\r\n          actor = result.actors[0];\r\n          allComponents = allComponents.concat(result.allComponents);\r\n        } else throw new Error(`The prefab \"${node.name}\" in scene \"${sceneAsset.name} has no scene defined.`);\r\n      } else {\r\n        actor = player.createActor(node.name, parentActor, { visible: node.visible, layer: node.layer });\r\n\r\n        if (prefabNode != null && parentActor === rootParentActor) {\r\n          actor.__inner.name = prefabNode.name;\r\n          actor.__inner.threeObject.visible = prefabNode.visible;\r\n\r\n          tmpVector3.set(node.position.x, node.position.y, node.position.z).add(prefabNode.position);\r\n          actor.__inner.setLocalPosition(tmpVector3);\r\n\r\n          const localOrientation = new SupEngine.THREE.Quaternion(node.orientation.x, node.orientation.y, node.orientation.z, node.orientation.w);\r\n          tmpQuaternion.set(prefabNode.orientation.x, prefabNode.orientation.y, prefabNode.orientation.z, prefabNode.orientation.w);\r\n          actor.__inner.setLocalOrientation(tmpQuaternion.multiply(localOrientation));\r\n\r\n          tmpVector3.set(node.scale.x, node.scale.y, node.scale.z).multiply(prefabNode.scale);\r\n          actor.__inner.setLocalScale(tmpVector3);\r\n        } else {\r\n          actor.__inner.setLocalPosition(tmpVector3.set(node.position.x, node.position.y, node.position.z));\r\n          actor.__inner.setLocalOrientation(tmpQuaternion.set(node.orientation.x, node.orientation.y, node.orientation.z, node.orientation.w));\r\n          actor.__inner.setLocalScale(tmpVector3.set(node.scale.x, node.scale.y, node.scale.z));\r\n        }\r\n\r\n        node.components.forEach((sceneComponent) => {\r\n          allComponents.push({\r\n            sceneComponent: sceneComponent,\r\n            actorComponent: player.createComponent(sceneComponent.type, actor, sceneComponent.config)\r\n          });\r\n        });\r\n\r\n        actor.__inner.awoken = false;\r\n        node.children.forEach((child) => { walk(child, actor); });\r\n      }\r\n\r\n      return actor;\r\n    }\r\n    sceneAsset.__inner.nodes.forEach((node) => { actors.push(walk(node, rootParentActor)); });\r\n\r\n    if (prefabNode != null) return { actors, allComponents };\r\n\r\n    allComponents.forEach((x) => {\r\n      SupRuntime.plugins[x.sceneComponent.type].setupComponent(player, x.actorComponent.__inner, x.sceneComponent.config);\r\n    });\r\n\r\n    const awakeActor = (actor) => {\r\n      if (actor.__inner.awoken) return;\r\n\r\n      actor.__inner.awoken = true;\r\n      actor.__inner.awake();\r\n      actor.getChildren().forEach((child) => { awakeActor(child); });\r\n    }\r\n    actors.forEach((actor) => { awakeActor(actor); });\r\n    return actors;\r\n  }\r\n}",
    defs: "declare namespace Sup {\r\n  function loadScene(sceneAsset: Scene): void;\r\n  function loadScene(sceneAssetPath: string): void;\r\n  function appendScene(sceneAsset: Scene, parent?: Actor): Actor[];\r\n  function appendScene(sceneAssetPath: string, parent?: Actor): Actor[];\r\n\r\n  class Scene extends Asset {\r\n    dummySceneMember;\r\n  }\r\n}\r\n",
});

},{}]},{},[1]);
